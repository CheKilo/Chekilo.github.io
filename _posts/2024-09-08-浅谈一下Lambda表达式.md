---
layout: post
title: 浅谈一下Lambda表达式
header-img: img/in-post/head/4.jpg
header-style: text
catalog: true
tags:
  - Java基础
---
聊一聊这个Java8引入的新特性。
{:.info}

### 1、函数式接口
在介绍Lambda表达式之前，我们首先要了解一下**函数式接口(Functional Interface)**。

函数式接口首先是一种[接口(Interface)](https://www.w3cschool.cn/java/java-interfaces.html)。其次，这种接口内部只能有一个未实现的抽象方法，这个抽象方法定义了 Lambda 表达式的签名和行为。

当然了，函数式接口内部可以多个default方法或static方法，这两类方法不会影响接口成为函数式接口。

在Java中，提供了一个注解 **@FunctionalInterface**，将这个注解添加在接口前，编译器会帮助我们检查接口是否符合函数式接口的定义。

这个注解并不是必须选项，但推荐使用它，可以增加可读性。

我们来看一下函数式接口的代码实现：
```java
@FunctionalInterface
public interface MyFunctionalInterface {
    // 抽象方法(接口中的方法是隐式抽象的，因此不必声明abstract)
    void doSomething();
    
    // 默认方法
    default void doSomethingElse() {
        System.out.println("Doing something else...");
    }
    
    // 静态方法
    static void doStaticThing() {
        System.out.println("Doing a static thing...");
    }
}
```


接下来我们来看一下Java内部提供的一个函数式接口**Runnable**，它的源码如下：

![Runnable实现](/img/in-post/2024-09-08/Runnable.png)

我们可以看见，它的实现非常简单，整个接口内就只有一个抽象方法**run()**，然后在接口上方标注了 **@FunctionalInterface**的注解。

如果你想使用这个函数式接口，那么必然就要创造实例，而我们又知道接口是无法直接创建实例的，那么该怎么办呢？

答案很简单，去写一个接口的实现类，然后创建该实现类的实例`斜眼笑`{:.emoji-plus}。

就像这样：
```java
//写一个函数式接口的实现类
public class MyRun implements Runnable{
  @Override
  void run(){
    System.out.println("具体实现");
  }
}

public class Demo {
  public static void main(String[] args) {
    //用实现类来创建实例，接着调用方法。
    Runnable myRunnable = new MyRun();
    myRunnable.run();
  }
}

```

这个方法很原始，但是也比较笨。

下面我们来介绍一种简化后的写法，即使用**匿名内部类**。

### 2、匿名内部类
首先，匿名内部类的出现解决了什么问题呢？

在实际开发中，我们常常遇见一种情况，某某接口内的方法只需要使用一次，但是为了使用它我们却不得不去写一个**实现类**，就像我们在上面介绍**Runnable接口**时做的那样。

仅仅为了一次调用，而去创建一个类，这未免也太麻烦了。

众所周知，code的尽头是偷懒`调皮`{:.emoji-plus}，所以**匿名内部类**应运而生了。

**匿名内部类**从它的名字就能看出来，它是一个没有显示定义类名的特殊类。

下面是它的使用方法：
```java
new 类名或者接口名(){
  @Override
  //重写方法
  
}
```

下面，我们来重新演示一下调用**函数式接口Runnable**中的**run( )** 方法。

```java
public class Demo {
  public static void main(String[] args) {
    //用实现类来创建实例，接着调用方法。
    Runnable myRunnable = new Runnable(){
      @Override
      void run(){
        //run的具体实现
        System.out.println("run......");
      }
    };
    myRunnable.run();
  }
}
```
或者，我们还能再偷懒一些。
```java
public class Demo {
  public static void main(String[] args) {
    //用实现类来创建实例，接着调用方法。
    new Runnable(){
      @Override
      void run(){
        //run的具体实现
        System.out.println("run......");
      }
    }.run();
  }
}
```
有些同学可能会有些疑惑，不是说接口不能实例化的吗？

这里出现的 **“Runnable myRunnable = new Runnable( ){...}”** 又是什么呢？

实际上，**new**后面跟着的**Runnable(){...}**，指代的并不是接口本身，而是指一个实现了接口的**匿名类**。

从本质上来说，这是将一个接口的实现类赋值给了接口，是**Java多态**的一种体现。

当然，匿名内部类也是有**规则**的。

**首先**，匿名内部类必须要**继承一个父类**，或者**实现一个接口**，而且**最多**只能继承一个父类或者实现一个接口。

**其次**，匿名内部类不可以是**抽象类**。

这个很好理解，匿名内部类本身就是为了去实现抽象类的方法，自然不能再成为抽象类。

或者可以换一个理解的角度。

我们在创建匿名内部类的同时，系统就会生成匿名内部类的实例对象。

而众所周知抽象类是不能创建对象的，所以匿名内部类自然也就不能是抽象类

**最后一点**，匿名内部类是不能定义构造器的。

我们都知道，构造方法是以类名来命名的，而我们的匿名内部类连类名都没有，又何从谈起定义构造器呢？

想必聪明的同学们又产生了疑惑，既然没有构造器，匿名内部类是怎么构造出实例化对象的呢`黑人问号`{:.emoji-plus}？

很简单，我没有构造方法，但是我的**父亲**有啊！

假如说匿名内部类继承了某个父类，那么它将会自动调用父类的构造方法。

这时候我们可以尝试在创建匿名内部类时添加参数。

Java会自动匹配调用父类中相应的有参构造方法，就像使用super(...)来调用父类构造方法一样，只不过这个调用是隐式完成的。

下面我们来举一个例子：
```java
// 定义一个父类，包含有参和无参构造方法
class Animal {
    private String name;

    // 无参构造方法
    public Animal() {
        this.name = "Unknown Animal";
        System.out.println("Animal created with default constructor.");
    }

    // 有参构造方法
    public Animal(String name) {
        this.name = name;
        System.out.println("Animal created with name: " + this.name);
    }

    // 打印动物名字的方法
    public void printName() {
        System.out.println("Animal name is: " + name);
    }
}

public class Main {
    public static void main(String[] args) {
        // 创建一个继承自Animal的匿名内部类，并调用父类的有参构造方法
        Animal myAnimal = new Animal("Lion") {
            // 可以重写父类的方法
            @Override
            public void printName() {
                System.out.println("This is an anonymous Lion.");
            }
        };

        // 调用重写的方法
        myAnimal.printName();
    }
}
```
通过打印我们可以发现，匿名内部类所实例化的对象myAnimal里，"Lion"确实已经被赋值给了**name**变量，证明有参构造方法调用成功。

不知道大家看到这里，是不是还产生了一个疑惑呢？`微笑`{:.emoji-plus}

匿名内部类继承了一个父类后，可以调用父类的构造器，这个很好理解。

但是如果一个匿名内部类是用来实现接口的，又该从哪里去找构造器呢？

接口是没有构造方法的啊`晕`{:.emoji-plus}！

聪明的同学们或许已经想到了，在Java中有一个顶级父类**Object**，任何类都需要继承它。

**Object**的源码：
![Object源码](/img/in-post/2024-09-08/Object.png)

>Class Object is the root of the class hierarchy. Every class has Object as a superclass. All objects, including arrays, implement the methods of this class.

看见没，**Object包含万物**，它的伟大无需多言`点赞`{:.emoji-plus}！

**匿名内部类**从本质上来说也是一个类，也就是说，它也会继承**Object**这个众类之父`doge`{:.emoji-plus}。

所以说，那些实现接口的匿名内部类，最终都会调用**Object**的构造方法。

学到这里我们可以发现，虽然说匿名内部类大大简化了函数式接口的实现过程，但是依旧会导致代码冗余。

那么，有没有什么更简单，更加可以偷懒的方式呢？

答案是肯定的！程序猿在偷懒这方面可是认真的！

下面，我们来隆重介绍本篇的主角，**Lambda表达式**。

### 3、Lambda表达式

to be continued
