---
layout: post
title: 说说Java里的泛型
header-img: img/in-post/head/6.jpg
header-style: text
catalog: true
tags:
  - Java基础
  - 泛型
  - 类型擦除
---
随便（bushi）说说Java的泛型。
{:.info}

首先，我们来思考一下什么是**泛型**。

泛（普遍的、广泛的）型（蓝图，模版、原型）。

这么一扩展，是不是顿时有一种恍然大悟，但又不知道悟出什么感觉`晕`{:.emoji-plus}？

所谓泛型程序设计，就是希望编写的代码能够对多种不同类型的对象重用。

比如说一个容器List，我们并不希望为收集String和Integer对象分别编写不同的容器代码，而是希望同样一段代码能够被复用。

### 1、泛型类
来让我们先看看泛型类是怎么定义的：

```java
public class Pair<T> {
  private T first;
  private T second;

  public Pair() {
    first = null;
    second = null;
  }

  public Pair(T first, T second) {
    this.first = first;
    this.second = second;
  }

  public T getFirst() {
    return first;
  }

  public T getSecond() {
    return second;
  }

  public void setFirst(T first) {
    this.first = first;
  }
  
  public void setSecond(T second){
    this.second = second;
  }
}
```

似乎没什么大区别，仅仅是在类名的后面跟了一个尖括号(钻石符号)<>,随后用尖括号里的T来代替数据类型。

泛型类中的尖括号 <> 里的字母被称为**类型参数**，它们是占位符，用于表示一个在实例化时指定的实际类型。

当然，尖括号里不一定非得用T，也不是只能写一个字母：
```java
public class Pair<T,U>{...}
```
这样也是完全可以的。

但是需要注意的是，**静态方法**和**静态变量**是不可以使用类型参数(T)来修饰的。

```java
public class Pair<T> {
  private T first;
  private T second;
  private static T createTime;//ERROR
  
  public T getCreateTime(){
    return createTime;
  }//ERROR
}
```
这里其实也比较好理解。

不论是静态变量还是静态方法，都是作为**类级别的属性和方法**，是在类实例构造前就已经初始化的。

而泛型的实际类型需要等**对象实例化后**才能确定，所以泛型的类型参数(T)自然就不能用来修饰静态。

```java
class Box<T> {
    public static void staticMethod(T item) { // 假设允许
        // 如何保证 T 的一致性？
    }
}

Box<String>.staticMethod("Hello");
Box<Integer>.staticMethod(123);
```
从概念上，静态方法的 T 是与实例绑定的.

如果静态方法能够访问 T，那么静态方法就不再是纯粹的静态方法，因为它依赖于实例提供的类型参数。

所以说这只是为了语言合理性而设计的规则，并不代表从技术上无法实现这种技术。

什么，你不信`斜眼笑`{:.emoji-plus}？那我们来看看下面的泛型方法。

### 2、泛型方法

### 3、通配符和限定

### 4、类型擦除

### 5、使用泛型的一些限制
